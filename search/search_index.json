{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"dbfread2 - Read DBF Files with Python","text":"<p>DBF is a file format used by databases such dBase, Visual FoxPro, and FoxBase+. This library reads DBF files and returns the data as native Python data types for further processing. It is primarily intended for batch jobs and one-off scripts.</p> <pre><code>from dbfread import DBF\nfor record in DBF('people.dbf'):\n    print(record)\n# {'NAME': 'Alice', 'BIRTHDATE': datetime.date(1987, 3, 1)}\n# {'NAME': 'Bob', 'BIRTHDATE': datetime.date(1980, 11, 12)}\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Pure Python implementation</li> <li>Support for Python 3.12+</li> <li>Returns data as native Python data types</li> <li>Memory efficient iteration</li> <li>Support for most common field types</li> <li>Support for pathlib.Path for all file operations</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Introduction and Tutorial</li> <li>API Documentation</li> <li>Field Types Reference</li> <li>Changelog</li> </ul>"},{"location":"api_changes/","title":"API Changes","text":""},{"location":"api_changes/#changes-from-dbfread-to-dbfread2","title":"Changes from dbfread to dbfread2","text":""},{"location":"api_changes/#new-features","title":"New Features","text":"<ul> <li>Full Python 3.12+ support</li> <li>Type hints throughout the codebase</li> <li>Support for <code>pathlib.Path</code> in all file operations</li> <li>Modern development tools (ruff, mypy)</li> <li>Improved documentation with Material for MkDocs</li> </ul>"},{"location":"api_changes/#breaking-changes","title":"Breaking Changes","text":"<ol> <li> <p>Removed deprecated functions:</p> </li> <li> <p><code>dbfread.open()</code></p> </li> <li> <p><code>dbfread.read()</code></p> </li> <li> <p><code>DBF</code> class is no longer a subclass of <code>list</code></p> </li> <li> <p>Cleaner and more explicit API</p> </li> <li>Better type safety</li> <li>Migration example:</li> </ol> <pre><code># Old code (dbfread)\ntable = dbfread.read('people.dbf')\nprint(table[1])  # Direct list access\n\n# New code (dbfread2)\ntable = DBF('people.dbf', load=True)\nprint(table.records[1])  # Explicit records access\n</code></pre>"},{"location":"api_changes/#compatibility-notes","title":"Compatibility Notes","text":"<ul> <li>The <code>DeprecatedDBF</code> class has been removed</li> <li>All file operations now accept both strings and <code>pathlib.Path</code> objects</li> <li>Python versions below 3.12 are no longer supported</li> </ul>"},{"location":"api_changes/#type-safety","title":"Type Safety","text":"<p>dbfread2 includes comprehensive type hints:</p> <pre><code>from dbfread2 import DBF\nfrom pathlib import Path\n\n# Both work\ntable1 = DBF('people.dbf')\ntable2 = DBF(Path('people.dbf'))\n\n# Type hints for records\nfor record in table1:\n    name: str = record['NAME']\n    age: int = record['AGE']\n</code></pre>"},{"location":"changes/","title":"Changelog","text":""},{"location":"changes/#010-2024-01-27","title":"0.1.0 (2024-01-27)","text":""},{"location":"changes/#added","title":"Added","text":"<ul> <li>Initial fork from dbfread</li> <li>Full Python 3.12+ support</li> <li>Type hints throughout the codebase</li> <li>Support for <code>pathlib.Path</code> in all file operations</li> <li>Modern development tools:</li> <li>ruff for linting and formatting</li> <li>mypy for static type checking</li> <li>mise-en-place for Python version management</li> <li>uv for dependency management</li> <li>Material for MkDocs documentation</li> </ul>"},{"location":"changes/#changed","title":"Changed","text":"<ul> <li>Removed deprecated <code>dbfread.open()</code> and <code>dbfread.read()</code></li> <li><code>DBF</code> class is no longer a subclass of <code>list</code></li> <li>Improved error messages and type safety</li> <li>Updated all dependencies to latest versions</li> <li>Modernized codebase structure</li> </ul>"},{"location":"changes/#removed","title":"Removed","text":"<ul> <li>Support for Python versions below 3.12</li> <li><code>DeprecatedDBF</code> class</li> <li>Legacy compatibility layers</li> </ul>"},{"location":"changes/#previous-versions","title":"Previous Versions","text":"<p>For changes in previous versions of the original dbfread library, please visit: dbfread changelog</p>"},{"location":"exporting_data/","title":"Exporting Data","text":"<p>dbfread2 makes it easy to export data to various formats and systems.</p>"},{"location":"exporting_data/#csv-export","title":"CSV Export","text":"<p>Using Python's built-in <code>csv</code> module:</p> <pre><code>import csv\nfrom dbfread2 import DBF\n\ntable = DBF('people.dbf')\n\nwith open('people.csv', 'w', newline='') as f:\n    writer = csv.writer(f)\n    writer.writerow(table.field_names)  # Write headers\n    for record in table:\n        writer.writerow([record[field] for field in table.field_names])\n</code></pre> <p>Output:</p> <pre><code>NAME,BIRTHDATE\nAlice,1987-03-01\nBob,1980-11-12\n</code></pre>"},{"location":"exporting_data/#pandas-dataframes","title":"Pandas DataFrames","text":"<pre><code>import pandas as pd\nfrom dbfread2 import DBF\n\ntable = DBF('people.dbf')\ndf = pd.DataFrame(iter(table))  # iter() is required\nprint(df)\n</code></pre> <p>Output:</p> <pre><code>        BIRTHDATE   NAME\n0  1987-03-01  Alice\n1  1980-11-12    Bob\n</code></pre> <p>Memory Usage</p> <p>Pandas will load all records into memory when creating the DataFrame. This is a limitation of pandas and cannot be avoided.</p>"},{"location":"exporting_data/#sql-with-dataset","title":"SQL with dataset","text":"<p>Using dataset for easy database operations:</p> <pre><code>import dataset\nfrom dbfread2 import DBF\n\n# Open database connection\ndb = dataset.connect('sqlite:///example.db')\n\n# Read DBF and insert into database\ntable = DBF('people.dbf')\ndb['people'].insert_many(iter(table))\n</code></pre> <p>This will:</p> <ol> <li>Create the table schema automatically</li> <li>Insert all records from the DBF file</li> </ol>"},{"location":"exporting_data/#command-line-export-to-sqlite","title":"Command Line Export to SQLite","text":"<p>dbfread2 includes a command-line tool for SQLite export:</p> <pre><code># Export to SQLite file\ndbfread2-sqlite -o example.sqlite table1.dbf table2.dbf\n\n# Print SQL to stdout\ndbfread2-sqlite table1.dbf table2.dbf\n\n# Handle encoding issues\ndbfread2-sqlite --encoding=latin1 -o example.sqlite table1.dbf\n</code></pre> <p>Features:</p> <ul> <li>Creates one table per DBF file</li> <li>Automatic schema creation</li> <li>Configurable character encoding</li> <li>Optional SQL output to stdout</li> </ul>"},{"location":"field_types/","title":"Field Types","text":""},{"location":"field_types/#supported-field-types","title":"Supported Field Types","text":"Type Field Type Python Type + autoincrement <code>int</code> @ time <code>datetime.datetime</code> 0 flags <code>bytes</code> (byte string) B double/memo <code>float</code> (Visual FoxPro) or <code>bytes</code> (other versions) C text <code>str</code> (unicode string) D date <code>datetime.date</code> or <code>None</code> F float <code>float</code> G OLE object <code>bytes</code> (byte string) I integer <code>int</code> L logical <code>bool</code> (<code>True</code>, <code>False</code>) or <code>None</code> M memo <code>str</code> (memo), <code>bytes</code> (picture/object) or <code>None</code> N numeric <code>int</code>, <code>float</code> or <code>None</code> O double <code>float</code> (floats are doubles in Python) P picture <code>bytes</code> (byte string) T time <code>datetime.datetime</code> V varchar <code>str</code> (unicode string) Y currency <code>decimal.Decimal</code> <p>Text Field Length</p> <p>Text values ('C') can be up to 65535 bytes long. While DBF was originally limited to 255 bytes, some vendors reuse the <code>decimal_count</code> field to get another byte for field length.</p> <p>Type B Field</p> <p>The 'B' field type serves two purposes: 1. Store double precision (64 bit) floats in Visual FoxPro databases 2. Store binary memos in other versions</p> <pre><code>dbfread2 examines the database version to parse and return the correct data type.\n</code></pre> <p>Type 0 Field</p> <p>The '0' field type is used for '_NullFlags' in Visual FoxPro. It was previously interpreted as an integer, but from version 2.0.1 onward it is returned as a byte string.</p> <p>Type V Field</p> <p>The 'V' field is an alternative character field used by Visual FoxPro. The binary version is not yet supported. See Microsoft Documentation for more details.</p>"},{"location":"field_types/#adding-custom-field-types","title":"Adding Custom Field Types","text":"<p>You can add new field types by subclassing <code>FieldParser</code>:</p> <pre><code>from dbfread2 import DBF, FieldParser\n\nclass MyFieldParser(FieldParser):\n    def parseC(self, field, data):\n        \"\"\"Custom parser for text fields\"\"\"\n        return data.rstrip(b' 0').decode(self.encoding)\n\ntable = DBF('data.dbf', parserclass=MyFieldParser)\n</code></pre>"},{"location":"field_types/#fieldparser-attributes","title":"FieldParser Attributes","text":"<p>The <code>FieldParser</code> class provides these attributes:</p> <ul> <li><code>self.table</code>: Reference to the <code>DBF</code> object (access headers, dbversion, etc.)</li> <li><code>self.encoding</code>: Character encoding (shortcut for <code>self.table.encoding</code>)</li> <li><code>self.char_decode_errors</code>: Error handling scheme for decoding</li> <li><code>self.dbversion</code>: Database version as integer</li> <li><code>self.get_memo(index)</code>: Get memo from memo file using field data index</li> <li><code>self.decode_text(text)</code>: Decode text using correct encoding and error handling</li> </ul>"},{"location":"field_types/#memo-types","title":"Memo Types","text":"<p>For Visual FoxPro (<code>.FPT</code>) files, <code>get_memo()</code> returns specialized types:</p> <pre><code>bytes\n\u2514\u2500\u2500 VFPMemo\n    \u251c\u2500\u2500 TextMemo\n    \u2514\u2500\u2500 BinaryMemo\n        \u251c\u2500\u2500 PictureMemo\n        \u2514\u2500\u2500 ObjectMemo\n</code></pre> <p>All types are subclasses of <code>bytes</code> to maintain compatibility while annotating memo types.</p>"},{"location":"field_types/#special-characters-in-field-type-names","title":"Special Characters in Field Type Names","text":"<p>For field types with special characters (like '+'), use the ASCII value in hexadecimal:</p> <pre><code># For field type '+', use:\ndef parse2B(self, field, data):  # 2B is hex for '+'\n    pass\n\n# To get the method name:\nmethod_name = 'parse' + format(ord('+'), 'x').upper()  # Returns 'parse2B'\n</code></pre>"},{"location":"field_types/#handling-invalid-values","title":"Handling Invalid Values","text":"<p>Instead of raising <code>ValueError</code> for invalid data, you can return raw data using <code>InvalidValue</code>:</p> <pre><code>from dbfread2 import DBF, FieldParser, InvalidValue\n\nclass SafeParser(FieldParser):\n    def parse(self, field, data):\n        try:\n            return super().parse(field, data)\n        except ValueError:\n            return InvalidValue(data)\n\ntable = DBF('data.dbf', parserclass=SafeParser)\nfor record in table:\n    for name, value in record.items():\n        if isinstance(value, InvalidValue):\n            print(f'Invalid value in {name}: {value!r}')\n</code></pre>"},{"location":"installing/","title":"Installation","text":""},{"location":"installing/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or later</li> <li>No external dependencies required - <code>dbfread2</code> is a pure Python module</li> </ul>"},{"location":"installing/#installing-with-pip","title":"Installing with pip","text":"<pre><code>pip install dbfread2\n</code></pre>"},{"location":"installing/#development-installation","title":"Development Installation","text":"<p>For development, we recommend using mise-en-place to manage Python versions and dependencies:</p> <ol> <li>Install mise-en-place</li> <li>Clone the repository:    <pre><code>git clone https://github.com/wasdee/dbfread2.git\ncd dbfread2\n</code></pre></li> <li>Set up the development environment:    <pre><code>mise install\n</code></pre></li> <li>Install development dependencies:    <pre><code>pip install -e \".[docs]\"\n</code></pre></li> </ol>"},{"location":"introduction/","title":"Introduction","text":"<p>This is a short introduction to the API. The example files used in this guide can be found in the <code>examples/files/</code> directory.</p>"},{"location":"introduction/#opening-a-dbf-file","title":"Opening a DBF File","text":"<pre><code>from dbfread2 import DBF\ntable = DBF('people.dbf')\n</code></pre> <p>You can iterate over records:</p> <pre><code>for record in table:\n    print(record)\n# {'NAME': 'Alice', 'BIRTHDATE': datetime.date(1987, 3, 1)}\n# {'NAME': 'Bob', 'BIRTHDATE': datetime.date(1980, 11, 12)}\n</code></pre> <p>Records will be returned in the order they appear in the file.</p> <p>You can count records:</p> <pre><code>len(table)  # Returns: 2\n</code></pre> <p>Deleted records are available in <code>deleted</code>:</p> <pre><code>for record in table.deleted:\n    print(record)\n# {'NAME': 'Deleted Guy', 'BIRTHDATE': datetime.date(1979, 12, 22)}\n\nlen(table.deleted)  # Returns: 1\n</code></pre> <p>You can also use the <code>with</code> statement:</p> <pre><code>with DBF('people.dbf') as table:\n    ...\n</code></pre> <p>Note</p> <p>The DBF object doesn't keep any files open, so the <code>with</code> statement is provided merely as a convenience.</p>"},{"location":"introduction/#streaming-vs-loading-records","title":"Streaming vs Loading Records","text":"<p>By default, records are streamed directly from disk, meaning only one record is in memory at a time.</p> <p>If you have enough memory, you can load all records into a list by passing <code>load=True</code>. This allows for random access:</p> <pre><code>table = DBF('people.dbf', load=True)\nprint(table.records[1]['NAME'])  # Returns: 'Bob'\nprint(table.records[0]['NAME'])  # Returns: 'Alice'\n</code></pre> <p>Deleted records are also loaded into a list in <code>table.deleted</code>.</p> <p>Alternatively, you can:</p> <ol> <li>Load records later by calling <code>table.load()</code></li> <li>Get a simple list of records with <code>records = list(DBF('people.dbf'))</code></li> <li>Unload records with <code>table.unload()</code></li> </ol> <p>Note</p> <p>If the table is not loaded, the <code>records</code> and <code>deleted</code> attributes return <code>RecordIterator</code> objects.</p>"},{"location":"introduction/#character-encodings","title":"Character Encodings","text":"<p>All text fields and memos (except binary ones) are returned as unicode strings.</p> <p>dbfread2 will:</p> <ol> <li>Try to detect the character encoding (code page) from the <code>language_driver</code> byte</li> <li>Fallback to ASCII if detection fails</li> <li>Allow override with <code>encoding='my-encoding'</code></li> </ol> <p>You can handle decoding errors with the <code>char_decode_errors</code> option, which is passed to <code>bytes.decode()</code>.</p>"},{"location":"introduction/#memo-files","title":"Memo Files","text":"<p>For files with memo fields, dbfread2 will look for the corresponding memo file:</p> <ul> <li><code>buildings.fpt</code> (Visual FoxPro)</li> <li><code>buildings.dbt</code> (other databases)</li> </ul>"},{"location":"introduction/#case-sensitivity","title":"Case Sensitivity","text":"<p>By default, dbfread2 ignores case in file names to handle mixed-case files in case-sensitive systems. You can disable this with <code>ignorecase=False</code>.</p>"},{"location":"introduction/#missing-memo-files","title":"Missing Memo Files","text":"<p>If a memo file is missing:</p> <ol> <li>A <code>MissingMemoFile</code> exception is raised by default</li> <li>Pass <code>ignore_missing_memofile=True</code> to continue with memo fields as <code>None</code></li> </ol>"},{"location":"introduction/#memo-file-support","title":"Memo File Support","text":"<ul> <li>Full support for Visual FoxPro (<code>.FPT</code>)</li> <li>Full support for dBase III (<code>.DBT</code>)</li> <li>Partial support for dBase IV (<code>.DBT</code>) - only with default 512-byte blocks</li> </ul>"},{"location":"introduction/#record-factories","title":"Record Factories","text":"<p>You can customize record format with the <code>recfactory</code> argument:</p> <pre><code>class Record:\n    def __init__(self, items):\n        for (name, value) in items:\n            setattr(self, name, value)\n\n# Use custom record class\nfor record in DBF('people.dbf', recfactory=Record, lowernames=True):\n    print(record.name, record.birthdate)\n</code></pre> <p>Pass <code>recfactory=None</code> to get the original <code>(name, value)</code> list.</p>"},{"location":"introduction/#custom-field-types","title":"Custom Field Types","text":"<p>You can add custom field types by subclassing <code>FieldParser</code>:</p> <pre><code>from dbfread2 import DBF, FieldParser\n\nclass ReverseTextParser(FieldParser):\n    def parseC(self, field, data):\n        # Return strings reversed\n        return data.rstrip(' 0').decode()[::-1]\n\nfor record in DBF('people.dbf', parserclass=ReverseTextParser):\n    print(record['NAME'])\n</code></pre>"},{"location":"introduction/#handling-invalid-values","title":"Handling Invalid Values","text":"<pre><code>from dbfread2 import DBF, FieldParser, InvalidValue\n\nclass SafeParser(FieldParser):\n    def parse(self, field, data):\n        try:\n            return FieldParser.parse(self, field, data)\n        except ValueError:\n            return InvalidValue(data)\n\ntable = DBF('invalid_value.dbf', parserclass=SafeParser)\nfor i, record in enumerate(table):\n    for name, value in record.items():\n        if isinstance(value, InvalidValue):\n            print(f'records[{i}][{name!r}] == {value!r}')\n</code></pre>"},{"location":"resources/","title":"Resources","text":""},{"location":"resources/#dbf-file-format-documentation","title":"DBF File Format Documentation","text":""},{"location":"resources/#official-documentation","title":"Official Documentation","text":"<ul> <li>Data File Header Structure for dBASE Version 7</li> <li>DBF Table File Structure (Microsoft)</li> </ul>"},{"location":"resources/#technical-references","title":"Technical References","text":"<ul> <li>Xbase File Format Description - Comprehensive guide by Erik Bachmann</li> <li>DBF Field Types and Specifications</li> <li>DBase File Structure</li> </ul>"},{"location":"resources/#additional-information","title":"Additional Information","text":"<ul> <li>Wikipedia article about dBase</li> <li>dBase IV limitations</li> </ul>"},{"location":"resources/#related-projects","title":"Related Projects","text":""},{"location":"resources/#python-packages","title":"Python Packages","text":"<ul> <li>dataset - Database abstraction layer</li> <li>pandas - Data analysis library</li> </ul>"},{"location":"resources/#alternative-dbf-libraries","title":"Alternative DBF Libraries","text":"<ul> <li>dbfpy - Pure Python DBF reader/writer</li> <li>pyDBF - DBF file reading library</li> </ul>"},{"location":"resources/#contributing","title":"Contributing","text":"<p>We welcome contributions! Check out our GitHub repository for:</p> <ul> <li>Issue tracking</li> <li>Feature requests</li> <li>Pull requests</li> <li>Development guidelines</li> </ul>"}]}